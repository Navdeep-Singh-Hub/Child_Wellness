EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_Y3VkZGx5LXN1bmJlYW0tODEuY2xlcmsuYWNjb3VudHMuZGV2JA
CLERK_PUBLISHABLE_KEY=pk_test_Y3VkZGx5LXN1bmJlYW0tODEuY2xlcmsuYWNjb3VudHMuZGV2JA
CLERK_SECRET_KEY=sk_test_AsHEqz1laFeDBibvwSFntXsqQPiOr8qHzay8crgTDc
MONGODB_URI=mongodb://127.0.0.1:27017/child_wellness
For AAC/kids apps, use:

Primary palette: sky-blue, soft green, coral, sunflower yellow, lilac.

Shadow color: #DDE6FF (soft pastel drop shadow).

Background: white card with subtle gradient overlay.

âœ… Rule of thumb: Each icon should be easily recognizable from 2â€“3 meters away (for children with visual processing differences).













/* AACgrid.tsx â€“ Kid-friendly, high-contrast UI (React Native Paper edition) */
import * as React from 'react';
import {
  Alert,
  FlatList,
  Image,
  KeyboardAvoidingView,
  LayoutAnimation,
  Modal,
  Platform,
  ScrollView,
  StyleSheet,
  TextInput as RNTextInput,
  View,
  TouchableOpacity,
  useWindowDimensions,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import * as ImagePicker from 'expo-image-picker';

/* â€”â€” Paper UI â€”â€” */
import {
  Avatar,
  Button,
  Card,
  Chip,
  Divider,
  FAB,
  IconButton,
  Surface,
  Text,
  TextInput,
  useTheme,
} from 'react-native-paper';

/* â€”â€” Your existing imports / helpers (keep these paths the same as your project) â€”â€” */
import { API_BASE_URL, addCustomTile, getCustomTiles, getFavorites, toggleFavorite, type CustomTile } from '@/utils/api';
import { CATEGORIES, CATEGORY_STYLES, COMMON_WORDS, tileImages, type Category, type Tile } from '@/constants/aac';

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Language / TTS â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
type LangKey = 'en-US' | 'hi-IN' | 'pa-IN' | 'ta-IN' | 'te-IN';
const LANG_OPTIONS: { key: LangKey; label: string; flag: string }[] = [
  { key: 'en-US', label: 'English', flag: 'ğŸ‡¬ğŸ‡§' },
  { key: 'hi-IN', label: 'à¤¹à¤¿à¤‚à¤¦à¥€', flag: 'ğŸ‡®ğŸ‡³' },
  { key: 'pa-IN', label: 'à¨ªà©°à¨œà¨¾à¨¬à©€', flag: 'ğŸ…¿ï¸' },
  { key: 'ta-IN', label: 'à®¤à®®à®¿à®´à¯', flag: 'ğŸ…£' },
  { key: 'te-IN', label: 'à°¤à±†à°²à±à°—à±', flag: 'ğŸ…£à±†' },
];

const TRANSLATIONS: Record<LangKey, Record<string, string>> = {
  'en-US': { i:'I', want:'want', more:'more', help:'help', go:'go', stop:'stop', yes:'yes', no:'no', please:'please', thankyou:'thank you',
    if:'if', this:'this', that:'that', then:'then', to:'to',
    car:'car', bike:'bike', train:'train', bus:'bus', plane:'plane',
    apple:'apple', banana:'banana', rice:'rice', milk:'milk', bread:'bread',
    doctor:'doctor', teacher:'teacher', police:'police', farmer:'farmer', chef:'chef',
    happy:'happy', sad:'sad', angry:'angry', tired:'tired', excited:'excited',
    eat:'eat', drink:'drink', open:'open', close:'close', play:'play',
  },
  'hi-IN': {}, 'pa-IN': {}, 'ta-IN': {}, 'te-IN': {},
};

let _voices: Speech.Voice[] | null = null;
async function loadVoices() {
  if (_voices) return _voices;
  try { _voices = await Speech.getAvailableVoicesAsync(); } catch { _voices = []; }
  return _voices!;
}
const LANG_MATCH: Record<LangKey, (v: Speech.Voice)=>boolean> = {
  'en-US': (v)=> v.language?.toLowerCase().startsWith('en'),
  'hi-IN': (v)=> v.language?.toLowerCase().startsWith('hi'),
  'pa-IN': (v)=> v.language?.toLowerCase().startsWith('pa') || v.name?.toLowerCase().includes('punjab'),
  'ta-IN': (v)=> v.language?.toLowerCase().startsWith('ta'),
  'te-IN': (v)=> v.language?.toLowerCase().startsWith('te'),
};
async function pickVoice(lang: LangKey) {
  const vs = await loadVoices();
  return vs.find(v => v.language?.toLowerCase() === lang.toLowerCase())
      || vs.find(LANG_MATCH[lang])
      || vs.find(LANG_MATCH['en-US'])
      || null;
}
const tWord = (id: string, lang: LangKey) => TRANSLATIONS[lang]?.[id] ?? id;
const tSentence = (ids: string[], lang: LangKey) => ids.map(w => tWord(w, lang)).join(' ');
async function speakSmart(text: string, lang: LangKey) {
  const voice = await pickVoice(lang);
  Speech.stop();
  Speech.speak(text, { language: voice?.language ?? 'en-US', voice: voice?.identifier, rate: lang === 'en-US' ? 1 : 0.95 });
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Tile Card â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function TileCard({
  tile,
  size,
  accent,
  isFav,
  onPress,
  onToggleFav,
  isCustom,
  onEdit,
  onDelete,
}: {
  tile: Tile;
  size: number;
  accent: string;
  isFav: boolean;
  onPress: (t: Tile) => void;
  onToggleFav: (id: string) => void;
  isCustom?: boolean;
  onEdit?: (t: Tile) => void;
  onDelete?: (t: Tile) => void;
}) {
  return (
    <Card mode="elevated" style={[styles.card, { width: size, height: size }]}>
      <LinearGradient
        colors={[accent + '40', '#ffffff']}
        start={{ x: 0, y: 0 }} end={{ x: 1, y: 1 }}
        style={StyleSheet.absoluteFill}
      />
      <Card.Content style={styles.cardContent}>
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
          {tile.imageUrl ? (
            <Image source={{ uri: tile.imageUrl }} style={{ width: size*0.72, height: size*0.56, resizeMode: 'contain' }} />
          ) : tile.imageKey && tileImages[tile.imageKey] ? (
            <Image source={tileImages[tile.imageKey]} style={{ width: size*0.72, height: size*0.56, resizeMode: 'contain' }} />
          ) : (
            <Text variant="displayLarge" style={{ fontSize: size*0.38, textAlign: 'center' }}>
              {'emoji' in tile && tile.emoji ? tile.emoji : 'ğŸŸ¦'}
            </Text>
          )}
        </View>

        <Surface elevation={2} style={styles.labelPill}>
          <Text variant="titleSmall" style={styles.labelText} numberOfLines={1}>{tile.label}</Text>
        </Surface>
      </Card.Content>

      <Card.Actions style={styles.cardActions}>
        {isCustom ? (
          <View style={{ flexDirection:'row' }}>
            <IconButton icon="pencil" size={18} onPress={()=>onEdit?.(tile)} accessibilityLabel="Edit tile" />
            <IconButton icon="delete-outline" size={18} onPress={()=>onDelete?.(tile)} accessibilityLabel="Delete tile" />
          </View>
        ) : <View />}

        <IconButton
          icon={isFav ? 'heart' : 'heart-outline'}
          iconColor={isFav ? '#ef4444' : undefined}
          size={20}
          onPress={() => onToggleFav(tile.id)}
          accessibilityLabel="Toggle favourite"
        />
      </Card.Actions>

      <TouchableOpacity
        style={StyleSheet.absoluteFill}
        activeOpacity={0.8}
        onPress={() => onPress(tile)}
        accessibilityRole="button"
      />
    </Card>
  );
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Main Screen â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
export default function AACgrid() {
  const theme = useTheme();
  const insets = useSafeAreaInsets();
  const { width } = useWindowDimensions();

  const [selectedLang, setSelectedLang] = React.useState<LangKey>('en-US');
  const [voiceAvailable, setVoiceAvailable] = React.useState<Record<LangKey, boolean>>({
    'en-US': true, 'hi-IN': false, 'pa-IN': false, 'ta-IN': false, 'te-IN': false,
  });

  const [activeCat, setActiveCat] = React.useState<Category['id']>('transport');
  const [query, setQuery] = React.useState('');
  const [utterance, setUtterance] = React.useState<string[]>([]);
  const [favorites, setFavorites] = React.useState<Set<string>>(new Set());
  const [customTiles, setCustomTiles] = React.useState<CustomTile[]>([]);

  // Add/Edit state
  const [addOpen, setAddOpen] = React.useState(false);
  const [editOpen, setEditOpen] = React.useState(false);
  const [saving, setSaving] = React.useState(false);
  const [uploading, setUploading] = React.useState(false);

  // Add form
  const [newId, setNewId] = React.useState('');
  const [newLabel, setNewLabel] = React.useState('');
  const [newEmoji, setNewEmoji] = React.useState('');
  const [sourceMode, setSourceMode] = React.useState<'url'|'upload'>('url');
  const [newImageUrl, setNewImageUrl] = React.useState('');
  const [pickedUri, setPickedUri] = React.useState('');

  // Edit form
  const [editForm, setEditForm] = React.useState<{ id: string; label: string; imageUrl?: string } | null>(null);

  // Columns: make tiles BIG for kids (min 2, max 4)
  const pagePadding = 16;
  const gap = 12;
  const maxCols = width >= 900 ? 4 : width >= 700 ? 3 : 2;
  const cols = maxCols;
  const tileSize = Math.floor((width - pagePadding*2 - gap*(cols-1)) / cols);

  // Category & filtered data
  const baseCats: Category[] = React.useMemo(() => {
    const favTiles: Tile[] = [];
    const every: Tile[] = [
      ...COMMON_WORDS,
      ...CATEGORIES.flatMap(c => c.tiles),
      ...customTiles.map(ct => ({ id: ct.id, label: ct.label, emoji: ct.emoji, imageUrl: ct.imageUrl } as Tile)),
    ];
    every.forEach(t => { if (favorites.has(t.id)) favTiles.push(t); });

    const favCat: Category = { id: 'favorites' as any, title: 'Favorites', color: '#FFE8A3', tiles: favTiles };
    const myCat: Category  = { id: 'mytiles'   as any, title: 'My Tiles', color: '#E0F2FE', tiles: customTiles.map(ct => ({ id: ct.id, label: ct.label, emoji: ct.emoji, imageUrl: ct.imageUrl })) };

    return [...CATEGORIES, favCat, myCat];
  }, [customTiles, favorites]);

  const category = React.useMemo(
    () => baseCats.find(c => c.id === activeCat) ?? baseCats[0],
    [activeCat, baseCats]
  );

  const filteredTiles = React.useMemo(() => {
    const q = query.trim().toLowerCase();
    const base = category.tiles;
    return q ? base.filter(t => t.label.toLowerCase().includes(q)) : base;
  }, [query, category]);

  // Effects
  React.useEffect(() => { (async () => {
    try { const fav = await getFavorites(); setFavorites(new Set(fav.favorites || [])); } catch {}
    try { const { tiles } = await getCustomTiles(); setCustomTiles(tiles || []); } catch {}
  })(); }, []);

  React.useEffect(() => { (async () => {
    const vs = await loadVoices();
    const next: Record<LangKey, boolean> = { ...voiceAvailable };
    (Object.keys(next) as LangKey[]).forEach(lk => {
      next[lk] = !!(vs.find(v => v.language?.toLowerCase() === lk.toLowerCase()) || vs.find(LANG_MATCH[lk]));
    });
    setVoiceAvailable(next);
  })(); /* eslint-disable-next-line */ }, []);

  React.useEffect(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
  }, [activeCat, query, width]);

  // Handlers
  const sayTile = async (t: Tile) => {
    Haptics.selectionAsync();
    setUtterance(prev => [...prev, t.id]);
    await speakSmart(tWord(t.id, selectedLang), selectedLang);
  };

  const saySentence = async () => {
    if (!utterance.length) return;
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    await speakSmart(tSentence(utterance, selectedLang), selectedLang);
  };

  const clearSentence = () => setUtterance([]);

  const onToggleFav = async (id: string) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    try {
      const { favorites: favList } = await toggleFavorite(id);
      setFavorites(new Set(favList));
    } catch { Alert.alert('Failed', 'Could not update favorites'); }
  };

  const onEdit = (t: Tile) => setEditForm({ id: t.id, label: t.label, imageUrl: (t as any).imageUrl });
  const onDelete = (t: Tile) => {
    const go = async () => {
      try {
        const { authHeaders } = await import('@/utils/api');
        await fetch(`${API_BASE_URL}/api/me/custom-tiles/${t.id}`, { method: 'DELETE', headers: await authHeaders() });
        setCustomTiles(prev => prev.filter(x => x.id !== t.id));
      } catch { Alert.alert('Delete failed'); }
    };
    if (Platform.OS === 'web') {
      if (confirm(`Delete "${t.label}"?`)) go();
    } else {
      Alert.alert('Delete tile', `Delete "${t.label}"?`, [
        { text: 'Cancel', style: 'cancel' },
        { text: 'Delete', style: 'destructive', onPress: go },
      ]);
    }
  };

  // Add tile helpers
  const pickImage = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') return Alert.alert('Permission needed', 'Please allow photo access.');
    const res = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 0.9 });
    if (!res.canceled) setPickedUri(res.assets[0].uri);
  };

  const uploadPicked = async (): Promise<string> => {
    if (!pickedUri) throw new Error('No image selected');
    setUploading(true);
    try {
      const form = new FormData();
      // @ts-ignore
      form.append('file', { uri: pickedUri, name: `img-${Date.now()}.jpg`, type: 'image/jpeg' });
      const { authHeaders } = await import('@/utils/api');
      const headers = await authHeaders?.({ multipart: true }) ?? {};
      if ('content-type' in (headers as any)) delete (headers as any)['content-type'];
      const r = await fetch(`${API_BASE_URL}/api/upload`, { method: 'POST', headers, body: form });
      if (!r.ok) throw new Error(await r.text());
      const data = await r.json();
      return data.url as string;
    } finally { setUploading(false); }
  };

  const saveNew = async () => {
    if (saving) return;
    if (!newId || !newLabel) return Alert.alert('Missing', 'ID and Label are required');
    setSaving(true);
    try {
      let finalUrl = sourceMode === 'url' ? (newImageUrl.trim() || undefined) : undefined;
      if (sourceMode === 'upload') {
        if (!pickedUri) return Alert.alert('No image', 'Choose an image to upload');
        finalUrl = await uploadPicked();
      }
      const { tile } = await addCustomTile({ id: newId.trim(), label: newLabel.trim(), emoji: newEmoji.trim() || undefined, imageUrl: finalUrl });
      setCustomTiles(prev => [...prev, tile]);
      setAddOpen(false);
      setNewId(''); setNewLabel(''); setNewEmoji(''); setNewImageUrl(''); setPickedUri('');
    } catch (e: any) {
      Alert.alert('Could not add', e?.message || 'Please try again');
    } finally { setSaving(false); }
  };

  const saveEdit = async () => {
    if (!editForm) return;
    try {
      const { authHeaders } = await import('@/utils/api');
      await fetch(`${API_BASE_URL}/api/me/custom-tiles/${editForm.id}`, {
        method: 'PUT',
        headers: await authHeaders(),
        body: JSON.stringify({ label: editForm.label, imageUrl: editForm.imageUrl }),
      });
      setCustomTiles(prev => prev.map(t => t.id === editForm.id ? { ...t, label: editForm.label, imageUrl: editForm.imageUrl } : t));
      setEditOpen(false); setEditForm(null);
    } catch { Alert.alert('Save failed'); }
  };

  /* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” UI â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
  const catTheme = CATEGORY_STYLES[activeCat];

  return (
    <KeyboardAvoidingView style={{ flex: 1, backgroundColor: catTheme.bg }} behavior={Platform.OS === 'ios' ? 'padding' : undefined}>
      {/* Header */}
      <LinearGradient
        colors={[catTheme.accent, catTheme.accent, catTheme.bg]}
        start={{ x: 0, y: 0 }} end={{ x: 0, y: 1 }}
        style={{ paddingTop: insets.top + 12, paddingBottom: 12, paddingHorizontal: 16 }}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
          <Text variant="headlineMedium" style={{ color: '#fff', fontWeight: '900' }}>
            AAC Grid
          </Text>

          {/* Language chips with availability dot */}
          <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 8 }}>
            {LANG_OPTIONS.map(opt => {
              const active = opt.key === selectedLang;
              const avail = voiceAvailable[opt.key];
              return (
                <Chip
                  key={opt.key}
                  selected={active}
                  mode={active ? 'flat' : 'outlined'}
                  onPress={() => setSelectedLang(opt.key)}
                  selectedColor="#fff"
                  style={[
                    styles.langChip,
                    active ? { backgroundColor: '#0b1220', borderColor: '#0b1220' } : { borderColor: 'rgba(255,255,255,0.7)' },
                    !avail && !active ? { opacity: 0.5 } : null,
                  ]}
                  textStyle={{ fontWeight: '800', color: '#fff' }}
                  icon={() => (
                    <View style={{ flexDirection:'row', alignItems:'center' }}>
                      <Text style={{ color:'#fff', marginRight: 6 }}>{opt.flag}</Text>
                      <View style={{
                        width: 8, height: 8, borderRadius: 999,
                        backgroundColor: avail ? '#22c55e' : '#ef4444'
                      }} />
                    </View>
                  )}
                >
                  {opt.label}
                </Chip>
              );
            })}
          </ScrollView>
        </View>

        {/* Search */}
        <View style={{ marginTop: 10 }}>
          <TextInput
            mode="outlined"
            placeholder="Search wordsâ€¦"
            value={query}
            onChangeText={setQuery}
            left={<TextInput.Icon icon="magnify" />}
            outlineStyle={{ borderColor: 'rgba(255,255,255,0.7)' }}
            style={{ backgroundColor: 'rgba(0,0,0,0.15)' }}
            textColor="#fff"
            placeholderTextColor="rgba(255,255,255,0.8)"
          />
        </View>
      </LinearGradient>

      {/* Sentence strip */}
      <Surface elevation={1} style={{ marginTop: -8, marginHorizontal: 16, borderRadius: 14, padding: 10, backgroundColor: '#fff' }}>
        {utterance.length === 0 ? (
          <Text variant="labelLarge" style={{ color: catTheme.accent, fontWeight: '900' }}>
            Build a sentenceâ€¦
          </Text>
        ) : (
          <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ alignItems: 'center' }}>
            {utterance.map((id, i) => (
              <Chip key={`${id}-${i}`} mode="flat" style={{ marginRight: 8, backgroundColor: '#eef2ff' }} textStyle={{ fontWeight: '900' }}>
                {tWord(id, selectedLang)}
              </Chip>
            ))}
          </ScrollView>
        )}

        <View style={{ flexDirection: 'row', gap: 10, marginTop: 10 }}>
          <Button mode="contained" icon="volume-high" onPress={saySentence} contentStyle={{ paddingVertical: 6 }} style={{ borderRadius: 10 }}>
            Speak
          </Button>
          <Button mode="outlined" icon="close-circle" onPress={clearSentence} contentStyle={{ paddingVertical: 6 }} style={{ borderRadius: 10 }}>
            Clear
          </Button>
        </View>
      </Surface>

      {/* Category chips */}
      <View style={{ marginTop: 12, paddingHorizontal: 16 }}>
        <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 8 }}>
          {baseCats.map(c => {
            const active = c.id === activeCat;
            return (
              <Chip
                key={c.id}
                selected={active}
                mode={active ? 'flat' : 'outlined'}
                onPress={() => setActiveCat(c.id)}
                selectedColor="#fff"
                style={[ styles.catChip, active ? { backgroundColor: catTheme.text, borderColor: catTheme.text } : { borderColor: catTheme.text } ]}
                textStyle={{ fontWeight: '900', color: active ? '#fff' : catTheme.text }}
              >
                {c.title}
              </Chip>
            );
          })}
        </ScrollView>
      </View>

      {/* Section heading */}
      <View style={{ paddingHorizontal: 16, marginTop: 12 }}>
        <Text variant="titleLarge" style={{ fontWeight: '900', color: catTheme.text }}>{CATEGORY_STYLES[activeCat].headerEmoji} {category.title}</Text>
        <View style={{ height: 4, backgroundColor: catTheme.accent, width: '40%', borderRadius: 999, marginTop: 6 }} />
      </View>

      {/* Grid */}
      <FlatList
        style={{ paddingHorizontal: 16, marginTop: 10 }}
        contentContainerStyle={{ paddingBottom: 120 }}
        data={filteredTiles}
        key={`${cols}-${category.id}`}
        numColumns={cols}
        keyExtractor={(t) => t.id}
        columnWrapperStyle={{ gap }}
        ItemSeparatorComponent={() => <View style={{ height: gap }} />}
        renderItem={({ item }) => (
          <TileCard
            tile={item}
            size={tileSize}
            accent={catTheme.accent}
            isFav={favorites.has(item.id)}
            onPress={sayTile}
            onToggleFav={onToggleFav}
            isCustom={customTiles.some(ct => ct.id === item.id)}
            onEdit={(t)=>{ setEditForm({ id: t.id, label: t.label, imageUrl: (t as any).imageUrl }); setEditOpen(true); }}
            onDelete={onDelete}
          />
        )}
      />

      {/* Add FAB */}
      <FAB
        icon="plus"
        label="Add Tile"
        onPress={()=> setAddOpen(true)}
        style={[styles.fab, { bottom: (insets.bottom || 12) + 16 }]}
        color="#fff"
        variant="primary"
      />

      {/* Add Modal */}
      <Modal visible={addOpen} transparent animationType="fade" onRequestClose={()=>setAddOpen(false)}>
        <View style={styles.modalBackdrop}>
          <Surface elevation={3} style={styles.modalCard}>
            <Text variant="titleLarge" style={{ fontWeight: '900' }}>Create custom tile</Text>
            <Divider style={{ marginVertical: 8 }} />
            <TextInput mode="outlined" label="ID (no spaces)" value={newId} onChangeText={setNewId} autoCapitalize="none" />
            <TextInput mode="outlined" label="Label" value={newLabel} onChangeText={setNewLabel} style={{ marginTop: 8 }} />
            <TextInput mode="outlined" label="Emoji (optional)" value={newEmoji} onChangeText={setNewEmoji} style={{ marginTop: 8 }} />

            <View style={{ flexDirection:'row', gap: 8, marginTop: 10 }}>
              <Chip selected={sourceMode==='url'} onPress={()=>setSourceMode('url')} icon="link">Image URL</Chip>
              <Chip selected={sourceMode==='upload'} onPress={()=>setSourceMode('upload')} icon="image">Upload</Chip>
            </View>

            {sourceMode === 'url' ? (
              <TextInput
                mode="outlined"
                label="Image URL"
                value={newImageUrl}
                onChangeText={setNewImageUrl}
                autoCapitalize="none"
                style={{ marginTop: 8 }}
              />
            ) : (
              <Surface elevation={1} style={styles.uploadBox}>
                <Button mode="outlined" icon="image-plus" onPress={pickImage}>
                  {pickedUri ? 'Change image' : 'Choose image from device'}
                </Button>
                {!!pickedUri && (
                  <View style={{ marginTop: 10, alignItems: 'center' }}>
                    <Image source={{ uri: pickedUri }} style={{ width: 120, height: 120, borderRadius: 12 }} />
                  </View>
                )}
              </Surface>
            )}

            <View style={{ flexDirection:'row', justifyContent:'flex-end', gap: 10, marginTop: 12 }}>
              <Button mode="text" onPress={()=>setAddOpen(false)} icon="close">Cancel</Button>
              <Button mode="contained" onPress={saveNew} icon={uploading ? 'upload' : 'content-save'} loading={saving || uploading}>
                {uploading ? 'Uploadingâ€¦' : saving ? 'Savingâ€¦' : 'Save'}
              </Button>
            </View>
          </Surface>
        </View>
      </Modal>

      {/* Edit Modal */}
      <Modal visible={editOpen || !!editForm} transparent animationType="fade" onRequestClose={()=>{ setEditOpen(false); setEditForm(null); }}>
        <View style={styles.modalBackdrop}>
          <Surface elevation={3} style={styles.modalCard}>
            <Text variant="titleLarge" style={{ fontWeight: '900' }}>Edit tile</Text>
            <Divider style={{ marginVertical: 8 }} />
            <TextInput mode="outlined" label="Label" value={editForm?.label ?? ''} onChangeText={(t)=>setEditForm(f => f ? { ...f, label: t } : f)} />
            <TextInput mode="outlined" label="Image URL (optional)" value={editForm?.imageUrl ?? ''} onChangeText={(t)=>setEditForm(f => f ? { ...f, imageUrl: t } : f)} style={{ marginTop: 8 }} />
            <View style={{ flexDirection:'row', justifyContent:'flex-end', gap: 10, marginTop: 12 }}>
              <Button mode="text" onPress={()=>{ setEditOpen(false); setEditForm(null); }} icon="close">Cancel</Button>
              <Button mode="contained" onPress={saveEdit} icon="content-save">Save</Button>
            </View>
          </Surface>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Styles â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
const styles = StyleSheet.create({
  catChip: { borderRadius: 999 },
  langChip: { borderRadius: 999 },
  card: {
    borderRadius: 18,
    overflow: 'hidden',
  },
  cardContent: { flex: 1, alignItems: 'center', justifyContent: 'space-between', paddingVertical: 10 },
  labelPill: {
    alignSelf: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: '#ffffff',
  },
  labelText: { fontWeight: '900', color: '#111827' },
  cardActions: { justifyContent: 'space-between', paddingHorizontal: 4, paddingBottom: 0 },

  fab: { position: 'absolute', right: 16, backgroundColor: '#2563EB' },
  modalBackdrop: { flex: 1, backgroundColor: 'rgba(0,0,0,0.35)', alignItems: 'center', justifyContent: 'center', padding: 16 },
  modalCard: { width: '100%', maxWidth: 460, padding: 16, borderRadius: 16, backgroundColor: '#fff' },
  uploadBox: { padding: 12, borderRadius: 12, backgroundColor: '#F3F4F6', marginTop: 8, alignItems: 'center' },
});
